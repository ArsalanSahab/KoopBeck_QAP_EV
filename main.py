"""
NOTE : SOME PARTS OF CODE IN THIS PROJECT HAVE BEEN INSPIRED FROM
"Filip Bachura from Wroclaw University of Science and Technology"
"""
import sys
import os.path
import time
import numpy as np

# Add current path to the system PATH to import local files
sys.path.append(os.path.join(os.path.dirname(__file__), ''))

from configurations import POPULATION_SIZE, NUMBER_OF_GENERATIONS, DRAW_VISUALIZATION, DATA_SET, DRAW_GRAPH, SLEEP_TIME
from load_data_set import array_size, flow_array, distance_array
from population_generator import generate_population
from fitness_func_configs import normalise_fitness_scores, get_fitness_scores
from selection_configs import Selection, TournamentSelection, RouletteSelection
from crossover_configs import BasicCrossover, Crossover
from mutation_configs import Mutation, BasicMutation
from turtle_visualisations import CustomDrawer
from draw_plot import PlotDrawer

# Select strategies from imported functions using the initialization functions
selection_strategy = Selection(selection_algorithm=TournamentSelection())
mutation_strategy = Mutation(mutation_algorithm=BasicMutation())
crossover_strategy = Crossover(crossover_algorithm=BasicCrossover())

def main():
    # Generate random population of chromosomes
    population = generate_population(array_size, POPULATION_SIZE)

    # Drawing classes for the turtle and plot
    turtle_drawer = CustomDrawer()
    plot_drawer = PlotDrawer()

    # Result arrays for plotting
    generation_indices = []
    average_results = []
    min_results = []
    max_results = []

    # Keep track of the last max_chromosome to avoid redundancy
    previous_max_chromosome = []

    # Implementing the turtle functions and iteratively drawing
    def draw_visual_frame():
        # The function takes flow and distance arrays, the best chromosome,
        # and other data and draws points and lines representing flow and distance
        turtle_drawer.draw_main_frame(
                max_chromosome, gen_count, max_fitness,
                max_chromosome, flow_array, distance_array
                )

        # Delay between each iteration of drawing
        time.sleep(SLEEP_TIME)

        return

    for gen_count in range(NUMBER_OF_GENERATIONS):
        # Calculate fitness from distance and flow using imported function
        fitness_scores = get_fitness_scores(population, distance_array, flow_array)
        # Normalize fitness score by inverting and dividing by the total
        fitness_scores_normalized = normalise_fitness_scores(fitness_scores)

        # While it's not normalized yet, max is the worst, therefore min is the most suitable
        # Use numpy to get min, max, and average
        max_fitness = np.min(fitness_scores)
        min_fitness = np.max(fitness_scores)
        average_fitness = np.mean(fitness_scores)
        max_chromosome = population[np.argmin(fitness_scores)]
        max_chromosome = list(map(lambda value: value + 1, max_chromosome))

        # Use the imported strategy functions to select chromosomes from
        # population based on the normalized scores
        selected_chromosomes = selection_strategy.select(population, fitness_scores_normalized)

        # Input the selected chromosomes to the imported crossover and mutation functions
        crossed_chromosomes = crossover_strategy.crossover(selected_chromosomes)
        mutated_chromosomes = mutation_strategy.mutate(crossed_chromosomes)

        # Print current values to the terminal
        print("Generation_Count: \t\t\t\t{}\nMean fitness.: \t\t\t{}\nMax score: \t\t\t{}\nMax chromosome.: \t\t{}\n\n"
              .format(gen_count, average_fitness, max_fitness, max_chromosome))

        # Call the turtle function via draw_visual_frame() unless
        # DRAW_VISUALIZATION is set to true or there was no change in the
        # chromosome
        if DRAW_VISUALIZATION and previous_max_chromosome != max_chromosome:
            draw_visual_frame()

        # Update the max chromosome
        previous_max_chromosome = max_chromosome

        # Update the population to the one generated by the mutation strategy
        population = mutated_chromosomes

        # For plot drawing
        # ----------------
        # Add fitness scores to the results arrays, to be used in plot drawing
        max_results.append(max_fitness)
        min_results.append(min_fitness)
        average_results.append(average_fitness)
        # Add an increment to the generation indices, for the x-axis of the plot
        generation_indices.append(gen_count)

    # Draw a plot using the generated results and open it in a browser
    # (unless DRAW_GRAPH is set to false)
    if DRAW_GRAPH:
        plot_drawer.drawPlot(DATA_SET, generation_indices, average_results, max_results, min_results)

    # Call Tkinter's mainloop function to start event loop
    # Essentially ends the drawing
    turtle_drawer.screen.mainloop()


if __name__ == "__main__":
    main()



